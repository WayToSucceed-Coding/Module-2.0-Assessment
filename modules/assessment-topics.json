{
    "moduleName": "Module 2.0",
    "topics": [
        {
            "name": "Functions",
            "description": "Covers functions, parameters, arguments, default arguments, positional and keyword arguments, variable scope (local, global, nonlocal), lambda functions, and advanced functions like map(), filter(), and zip().",
            "mcqs": [
                {
                    "question": "What will the following code print?\n\ndef greet(name='Student'):\n    print('Hello', name)\n\ngreet()",
                    "options": [
                        "Hello",
                        "Hello Student",
                        "Error: missing argument",
                        "Hello name"
                    ],
                    "answer": 1,
                    "explanation": "Since no argument is passed, the default value 'Student' is used."
                },
                {
                    "question": "Which of the following calls will cause an error?\n\ndef student_info(name, grade, roll_no):\n    print(name, grade, roll_no)",
                    "options": [
                        "student_info('Ravi', 7, 12)",
                        "student_info(roll_no=12, name='Ravi', grade=7)",
                        "student_info('Ravi', roll_no=12, grade=7)",
                        "student_info('Ravi', 12)"
                    ],
                    "answer": 3,
                    "explanation": "The last call provides only two arguments instead of three required positional arguments."
                },
                {
                    "question": "What does the nonlocal keyword do?",
                    "options": [
                        "Makes a variable global",
                        "Refers to a variable in the enclosing function's scope",
                        "Declares a local variable",
                        "Deletes a variable"
                    ],
                    "answer": 1,
                    "explanation": "Nonlocal allows inner functions to modify variables in their enclosing function without making them global."
                },
                {
                    "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4]\nresult = list(map(lambda x: x * 2, numbers))\nprint(result)",
                    "options": [
                        "[1, 2, 3, 4]",
                        "[2, 4, 6, 8]",
                        "[1, 4, 9, 16]",
                        "Error"
                    ],
                    "answer": 1,
                    "explanation": "The map function applies the lambda function to each element, doubling them."
                },
                {
                    "question": "What does the following filter code return?\n\nnumbers = [10, 25, 30, 15]\nresult = list(filter(lambda x: x > 20, numbers))\nprint(result)",
                    "options": [
                        "[10, 25, 30, 15]",
                        "[25, 30]",
                        "[10, 15]",
                        "[25, 30, 15]"
                    ],
                    "answer": 1,
                    "explanation": "The filter function returns only elements greater than 20."
                },
                {
                    "question": "What will be the result of this code?\n\nlist(zip([1, 2, 3], ['a', 'b', 'c']))",
                    "options": [
                        "[(1, 'a'), (2, 'b'), (3, 'c')]",
                        "[(1, 'b'), (2, 'c'), (3, 'a')]",
                        "[1, 'a', 2, 'b', 3, 'c']",
                        "Error"
                    ],
                    "answer": 0,
                    "explanation": "The zip function pairs elements by position into tuples."
                }
            ],
            "codeTasks": [
                {
                    "question": "You need to create a system that applies a bonus to multiple student marks.\n\nSteps:\n1. Create a global variable `bonus` and assign it the value 5.\n2. Define a function `process_marks(*args)` that accepts any number of student marks.\n3. Inside `process_marks`, create a variable `total_bonus` initialized to 0 to track the cumulative bonus.\n4. Define a nested function `apply_bonus(mark)`:\n   a. Declare `total_bonus` as nonlocal.\n   b. Increment `total_bonus` by the global `bonus`.\n   c. Return the sum of `mark` and the global `bonus`.\n5. After defining `apply_bonus`, use the `map()` function to apply it to each mark passed to `process_marks`. Convert the result to a list called `new_marks`.\n6. Return `new_marks` from `process_marks`.\n\nExample: Calling `process_marks(70, 80, 90)` should return `[75, 85, 95]`.",
                    "starterCode": "# Your code here",
                    "expectedOutput": "[75, 85, 95]",
                    "solutionCode": "bonus = 5\n\ndef process_marks(*args):\n    total_bonus = 0\n    def apply_bonus(mark):\n        nonlocal total_bonus\n        total_bonus += bonus\n        return mark + bonus\n    new_marks = list(map(apply_bonus, args))\n    return new_marks",
                    "testCases": [
                        {
                            "mode": "function",
                            "call": {
                                "name": "process_marks",
                                "args": [
                                    70,
                                    80,
                                    90
                                ]
                            },
                            "expectedReturn": [
                                75,
                                85,
                                95
                            ]
                        },
                        {
                            "mode": "function",
                            "call": {
                                "name": "process_marks",
                                "args": [
                                    50,
                                    60
                                ]
                            },
                            "expectedReturn": [
                                55,
                                65
                            ]
                        }
                    ],
                    "structureRequirements": {
                        "functions": [
                            "process_marks",
                            "apply_bonus"
                        ],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ]
                    }
                }
            ]
        },
        {
            "name": "Comprehensions",
            "description": "Covers list, set, and dictionary comprehensions, and sorting dictionaries.",
            "mcqs": [
                {
                    "question": "What will be the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [x for x in numbers if x % 2 == 0]\nprint(even_numbers)",
                    "options": [
                        "[1, 2, 3, 4, 5]",
                        "[2, 4]",
                        "[1, 3, 5]",
                        "Error"
                    ],
                    "answer": 1,
                    "explanation": "Only even numbers (2 and 4) are included in the new list."
                },
                {
                    "question": "Which of the following creates a set of unique vowels from the string 'education'?",
                    "options": [
                        "{char for char in 'education' if char in 'aeiou'}",
                        "[char for char in 'education' if char in 'aeiou']",
                        "(char for char in 'education' if char in 'aeiou')",
                        "set([char for char in 'education' if char in 'aeiou'])"
                    ],
                    "answer": 0,
                    "explanation": "Set comprehension uses curly braces {}. '{char for char in 'education' if char in 'aeiou'}' creates a set of unique vowels from the string."
                },
                {
                    "question": "Given fruits = {'apple':4, 'banana':2, 'orange':6}, how can you get a dictionary with only fruits that have quantity more than 3?",
                    "options": [
                        "{k:v for k,v in fruits.items() if v>3}",
                        "[k:v for k,v in fruits.items() if v>3]",
                        "fruits.keys()",
                        "fruits.values()"
                    ],
                    "answer": 0,
                    "explanation": "Dictionary comprehension allows filtering items by value; only keys with value > 3 are included."
                },
                {
                    "question": "How can you create a dictionary from two lists, one containing keys and the other values?",
                    "options": [
                        "{k:v for k,v in zip(keys, values)}",
                        "[k:v for k,v in zip(keys, values)]",
                        "{keys, values}",
                        "zip(keys, values)"
                    ],
                    "answer": 0,
                    "explanation": "Dictionary comprehension combined with zip() allows mapping each key to its corresponding value."
                }
            ],
            "codeTasks": [
                {
                    "question": "You need to sort a dictionary by its values in descending order.\n\nSteps:\n1. Create a dictionary called 'fruits' with these key-value pairs: 'apple': 4, 'banana': 2, 'orange': 6.\n2. Convert the dictionary into a list of tuples called 'items' using the items() method: items = list(fruits.items()).\n3. Sort the 'items' list in-place using items.sort(key=lambda x: x[1], reverse=True) and store the result in a variable called 'sorted_items'.\n4. Print sorted_items to see the result.\n\nExample: After sorting, sorted_items should be [('orange', 6), ('apple', 4), ('banana', 2)].",
                    "starterCode": "# Step 1: Create the dictionary\n# Step 2: Convert dictionary to list of tuples\n# Step 3: Sort the list in-place and store in 'sorted_items'\n# Step 4: Print 'sorted_items'",
                    "expectedOutput": "[['orange', 6], ['apple', 4], ['banana', 2]]",
                    "solutionCode": "fruits = {'apple': 4, 'banana': 2, 'orange': 6}\nitems = list(fruits.items())\nitems.sort(key=lambda x: x[1], reverse=True)\nsorted_items = items\nprint(sorted_items)",
                    "testCases": [
                        {
                            "mode": "function",
                            "call": {
                                "name": "sorted_items",
                                "args": []
                            },
                            "expectedReturn": [
                                [
                                    "orange",
                                    6
                                ],
                                [
                                    "apple",
                                    4
                                ],
                                [
                                    "banana",
                                    2
                                ]
                            ]
                        }
                    ],
                    "structureRequirements": {
                        "functions": [],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ]
                    }
                }
            ]
        },
        {
            "name": "Classes and Objects",
            "description": "Covers classes, objects, attributes, methods, __init__() method, self parameter, and how to create and use objects in Python.",
            "mcqs": [
                {
                    "question": "Which of the following best describes a class in Python?",
                    "options": [
                        "A template that defines properties and behaviors",
                        "A specific object created from a template",
                        "A function inside an object",
                        "A variable storing data"
                    ],
                    "answer": 0,
                    "explanation": "A class acts as a template that defines the common attributes and methods for all objects created from it."
                },
                {
                    "question": "What is an object in Python?",
                    "options": [
                        "A template for creating classes",
                        "An instance of a class",
                        "A function inside a class",
                        "A variable storing a method"
                    ],
                    "answer": 1,
                    "explanation": "An object is an instance of a class with its own set of attribute values."
                },
                {
                    "question": "What is the purpose of the __init__() method in a class?",
                    "options": [
                        "It deletes an object when it is no longer needed",
                        "It initializes object attributes when the object is created",
                        "It defines a class-level variable",
                        "It converts a class into a function"
                    ],
                    "answer": 1,
                    "explanation": "__init__() is called automatically when an object is created, allowing initialization of the object's attributes."
                },
                {
                    "question": "In a class method, what does the self parameter represent?",
                    "options": [
                        "The class itself",
                        "The current object that calls the method",
                        "A global variable",
                        "A local function inside the class"
                    ],
                    "answer": 1,
                    "explanation": "self represents the specific object calling the method, allowing access to its attributes and other methods."
                }
            ],
            "codeTasks": [
                {
                    "question": "You need to create a Book class and create objects with customized attributes.\n\nSteps:\n1. Define a class called Book.\n2. Inside the class, define an __init__() method with parameters: self, title, author, pages.\n3. Inside __init__(), assign the parameters to the object's attributes (self.title = title, etc.).\n4. Add a method called read_book(self) that prints 'Reading <title> by <author>'.\n5. Create two objects of Book with different values for title, author, and pages.\n6. Call the read_book() method on both objects to see the output.",
                    "starterCode": "# Step 1: Define the Book class\n# Step 2: Define __init__() with parameters\n# Step 3: Assign attributes inside __init__\n# Step 4: Define read_book() method\n# Step 5: Create two Book objects\n# Step 6: Call read_book() method on each object",
                    "expectedOutput": "Reading 1984 by George Orwell\nReading To Kill a Mockingbird by Harper Lee",
                    "solutionCode": "class Book:\n    def __init__(self, title, author, pages):\n        self.title = title\n        self.author = author\n        self.pages = pages\n\n    def read_book(self):\n        print(f'Reading {self.title} by {self.author}')\n\nbook1 = Book('1984', 'George Orwell', 328)\nbook2 = Book('To Kill a Mockingbird', 'Harper Lee', 281)\n\nbook1.read_book()\nbook2.read_book()",
                    "testCases": [
                        {
                            "mode": "function",
                            "call": {
                                "name": "book1.read_book",
                                "args": []
                            },
                            "expectedReturn": "Reading 1984 by George Orwell"
                        },
                        {
                            "mode": "function",
                            "call": {
                                "name": "book2.read_book",
                                "args": []
                            },
                            "expectedReturn": "Reading To Kill a Mockingbird by Harper Lee"
                        }
                    ],
                    "structureRequirements": {
                        "functions": [
                            "read_book"
                        ],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ]
                    }
                }
            ]
        },
        {
            "name": "Polymorphism",
            "description": "Covers polymorphism in Python, including operators, built-in functions, and method overriding in classes.",
            "mcqs": [
                {
                    "question": "What does polymorphism mean in programming?",
                    "options": [
                        "A single object type has only one form",
                        "Operators, functions, and methods can behave differently depending on the object type",
                        "Creating multiple copies of an object",
                        "Restricting functions to only one type of input"
                    ],
                    "answer": 1,
                    "explanation": "Polymorphism allows operators (like +, *), built-in functions (like len()), and methods to behave differently depending on the type of object they are applied to. For example, + adds numbers, concatenates strings, and merges lists; len() returns the length of strings, lists, or dictionaries; and a method like generate() can behave differently in different classes."
                },
                {
                    "question": "Which of the following demonstrates polymorphism in Python, where the same operation behaves differently depending on the type of object?",
                    "options": [
                        "Using len() on a list, string, and dictionary, and using + with numbers and strings",
                        "Defining two classes with the same method name performing different tasks",
                        "Calling a function with the same argument type multiple times",
                        "Creating multiple objects of the same class"
                    ],
                    "answer": 0,
                    "explanation": "Polymorphism allows the same operation to behave differently based on the object type. For example, len() returns the number of elements for a list, the number of characters for a string, and the number of key-value pairs for a dictionary. Similarly, + adds numbers but concatenates strings. This is a clear example of polymorphism in Python using both functions and operators."
                },
                {
                    "question": "Which of the following demonstrates polymorphism in OOP?",
                    "options": [
                        "A method with the same name performing differently in two classes",
                        "A class having only one method",
                        "Using only numbers with operators",
                        "Creating objects without methods"
                    ],
                    "answer": 0,
                    "explanation": "Polymorphism in OOP allows a method with the same name to behave differently depending on the class it belongs to."
                }
            ],
            "codeTasks": [
                {
                    "question": "Write a program that demonstrates polymorphism using the + operator with different data types. Create the following variables and use the + operator, then print each result:\n\n1. num1 = 10, num2 = 5 (addition)\n2. word1 = 'Hello', word2 = 'World' (concatenation)\n3. list1 = [1, 2], list2 = [3, 4] (merging lists)\n\nShow how the same + operator behaves differently with numbers, strings, and lists.",
                    "starterCode": "# Demonstrate + operator polymorphism\n# Your code here",
                    "expectedOutput": "15\nHelloWorld\n[1, 2, 3, 4]",
                    "solutionCode": "num1 = 10\nnum2 = 5\nword1 = 'Hello'\nword2 = 'World'\nlist1 = [1, 2]\nlist2 = [3, 4]\n\nprint(num1 + num2)\nprint(word1 + word2)\nprint(list1 + list2)",
                    "testCases": [
                        {
                            "mode": "io",
                            "input": [],
                            "expected": "15\nHelloWorld\n[1, 2, 3, 4]"
                        }
                    ],
                    "structureRequirements": {
                        "functions": [],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ]
                    }
                }
            ]
        },
        {
            "name": "Inheritance",
            "mcqs": [
                {
                    "question": "What does inheritance in Python allow you to do?",
                    "options": [
                        "Create multiple copies of the same object",
                        "Allow a child class to reuse attributes and methods from a parent class",
                        "Restrict a class to use only one attribute",
                        "Prevent method overriding"
                    ],
                    "answer": 1,
                    "explanation": "Inheritance allows a child class to reuse attributes and methods from a parent class, avoiding code duplication."
                },
                {
                    "question": "What happens if a child class defines its own __init__() method without calling the parent’s __init__()?",
                    "options": [
                        "It keeps all parent attributes automatically",
                        "It loses the parent’s attributes unless they are explicitly called",
                        "It cannot define its own attributes",
                        "It throws an error"
                    ],
                    "answer": 1,
                    "explanation": "When the child’s __init__() overrides the parent’s __init__() without calling it, the parent’s attributes are not inherited."
                },
                {
                    "question": "Which function is used to call the parent’s __init__() method without explicitly naming the parent class?",
                    "options": [
                        "self()",
                        "parent()",
                        "base()",
                        "super()"
                    ],
                    "answer": 3,
                    "explanation": "The super() function lets you call the parent class’s __init__() method (and other methods) without explicitly mentioning the parent class’s name."
                },
                {
                    "question": "If a child class has a method with the same name as in the parent class, what happens?",
                    "options": [
                        "The parent’s method is automatically removed",
                        "Both methods run one after another",
                        "The parent’s method is overridden by the child’s method",
                        "Python throws an error"
                    ],
                    "answer": 2,
                    "explanation": "When a child method has the same name as a parent method, the parent’s version is overridden."
                },
                {
                    "question": "What does isinstance(obj, ClassName) return?",
                    "options": [
                        "The class name of the object",
                        "True if obj is an instance of ClassName, otherwise False",
                        "The parent class of obj",
                        "The attributes of the object"
                    ],
                    "answer": 1,
                    "explanation": "isinstance() checks if an object is an instance of a particular class and returns True or False."
                }
            ],
            "codeTasks": [
                {
                    "question": "Complete the code to demonstrate inheritance and overriding with super().\n\nSteps:\n1. Create a parent class Person with a method introduce() that prints 'I am a person'.\n2. Create a child class Student that overrides introduce().\n3. Inside Student's introduce(), first call the parent's introduce() using super(), then print 'I am also a student'.\n4. Create a Student object and call introduce().",
                    "starterCode": "class Person:\n    def introduce(self):     \n       pass\n",
                    "solutionCode": "class Person:\n    def introduce(self):\n        print('I am a person')\n\nclass Student(Person):\n    def introduce(self):\n        super().introduce()\n        print('I am also a student')\n\nstudent1 = Student()\nstudent1.introduce()",
                    "expectedOutput": "I am a person\nI am also a student",
                    "testCases": [
                        {
                            "mode": "function",
                            "call": {
                                "name": "Student",
                                "args": []
                            },
                            "expectedReturn": null
                        }
                    ],
                    "structureRequirements": {
                        "classes": [
                            "Person",
                            "Student"
                        ],
                        "functions": [
                            "introduce"
                        ],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ]
                    }
                }
            ]
        },
        {
            "name": "Encapsulation",
            "description": "Students will learn how encapsulation bundles data and methods into a single unit (class), protecting sensitive information and restricting access using public and private members.",
            "mcqs": [
                {
                    "question": "What is encapsulation in object-oriented programming?",
                    "options": [
                        "Grouping unrelated classes together",
                        "Bundling data and methods into a single unit and restricting access from outside",
                        "Writing all functions in a single file",
                        "Separating the code into multiple modules"
                    ],
                    "answer": 1,
                    "explanation": "Encapsulation involves combining data (attributes) and methods into a class and controlling access to protect sensitive information."
                },
                {
                    "question": "Why is encapsulation important?",
                    "options": [
                        "It allows the code to run faster",
                        "It protects sensitive data, prevents accidental modification, and keeps code organized",
                        "It ensures inheritance works properly",
                        "It eliminates the need for methods"
                    ],
                    "answer": 1,
                    "explanation": "Encapsulation provides data protection, avoids misuse, and organizes related data and methods together."
                },
                {
                    "question": "In the ATM analogy, which attribute should be public?",
                    "options": [
                        "The actual PIN stored in the bank",
                        "The entered PIN input by the user",
                        "The verify() method",
                        "The internal cash counter"
                    ],
                    "answer": 1,
                    "explanation": "The entered PIN is public because the user needs to access and modify it using the keypad."
                },
                {
                    "question": "How do you define a private attribute in Python?",
                    "options": [
                        "Add a single underscore before its name",
                        "Add two underscores before its name",
                        "Use the private keyword",
                        "Use the protected keyword"
                    ],
                    "answer": 1,
                    "explanation": "Private attributes in Python are defined by prefixing the name with two underscores (e.g., __actual_pin)."
                },
                {
                    "question": "What happens if you try to access a private attribute outside the class?",
                    "options": [
                        "It prints the value normally",
                        "It raises an AttributeError",
                        "It automatically converts it to a public attribute",
                        "Python ignores the private keyword"
                    ],
                    "answer": 1,
                    "explanation": "Private attributes cannot be accessed outside the class; attempting to do so raises an AttributeError."
                },
                {
                    "question": "Which of the following is true about public methods?",
                    "options": [
                        "They can only be used inside the class",
                        "They can be accessed both inside and outside the class",
                        "They cannot access private attributes",
                        "They are automatically abstract"
                    ],
                    "answer": 1,
                    "explanation": "Public methods can be accessed and called both inside and outside the class."
                },
                {
                    "question": "How do you make a method private in Python?",
                    "options": [
                        "Add two underscores before its name",
                        "Add a single underscore before its name",
                        "Use the private keyword",
                        "Use the static keyword"
                    ],
                    "answer": 0,
                    "explanation": "A method is made private by adding two underscores before its name (e.g., __verify())."
                },
                {
                    "question": "In the ATM example, why is the verify() method made private?",
                    "options": [
                        "To allow users to change the actual PIN",
                        "To restrict access to the internal mechanism of checking the PIN",
                        "To speed up the program",
                        "To make the PIN public"
                    ],
                    "answer": 1,
                    "explanation": "The verify() method is private to prevent users from accessing or modifying the internal PIN-checking logic."
                },
                {
                    "question": "What is the purpose of the check() method in the ATM class?",
                    "options": [
                        "To act as the public interface that calls the private verify() method",
                        "To store the actual PIN",
                        "To allow users to modify the bank database",
                        "To generate a random PIN"
                    ],
                    "answer": 0,
                    "explanation": "The check() method is public and acts as an interface, calling the private verify() method internally."
                },
                {
                    "question": "Which of the following is a key advantage of using private members?",
                    "options": [
                        "They allow accidental modification of sensitive data",
                        "They protect data from outside interference and misuse",
                        "They make code run slower",
                        "They prevent the use of public methods"
                    ],
                    "answer": 1,
                    "explanation": "Private members safeguard sensitive information and prevent accidental or unauthorized changes."
                }
            ]
        },
        {
            "name": "Abstraction",
            "description": "In this topic, students will learn about abstraction in Python, which allows defining rules in a base class that all child classes must follow. They will explore creating abstract classes and methods using the abc module, and implement child classes that provide specific behavior.",
            "mcqs": [
                {
                    "question": "What is an abstract class in Python?",
                    "options": [
                        "A class that can be instantiated directly",
                        "A class that defines rules (methods) for child classes",
                        "A class with only concrete methods",
                        "A class that can only inherit from other classes"
                    ],
                    "answer": 1,
                    "explanation": "An abstract class defines a set of methods that child classes must implement and cannot be instantiated if it has abstract methods."
                },
                {
                    "question": "Which module provides tools to create abstract classes and methods in Python?",
                    "options": [
                        "random",
                        "abc",
                        "sys",
                        "time"
                    ],
                    "answer": 1,
                    "explanation": "The abc module (Abstract Base Class) allows creation of abstract classes and abstract methods."
                },
                {
                    "question": "What happens if a child class does not implement all abstract methods from the parent class?",
                    "options": [
                        "It will work normally",
                        "Python will allow instantiation but give a warning",
                        "You cannot create an object of that child class",
                        "It converts abstract methods to concrete automatically"
                    ],
                    "answer": 2,
                    "explanation": "If a child class does not implement all abstract methods, Python will prevent instantiation of that class."
                },
                {
                    "question": "What is the purpose of an abstract method?",
                    "options": [
                        "To provide full implementation that child classes can use",
                        "To define a rule that child classes must follow without giving implementation",
                        "To execute code faster",
                        "To make a class private"
                    ],
                    "answer": 1,
                    "explanation": "An abstract method has no implementation and requires each child class to provide its own version."
                },
                {
                    "question": "Can you create an object of an abstract class with no abstract methods?",
                    "options": [
                        "Yes, if there are no abstract methods",
                        "No, never",
                        "Yes, only if it inherits another class",
                        "No, only concrete classes can be instantiated"
                    ],
                    "answer": 0,
                    "explanation": "If an abstract class has no abstract methods, it can be instantiated like a normal class."
                }
            ],
            "codeTasks": [
                {
                    "question": "Create an abstract Payment system using the abc module.\n\nSteps to follow:\n1. Import ABC and abstractmethod from the abc module.\n2. Create an abstract class Payment that has:\n   - A concrete method payment_info() that prints 'This is a payment system for processing transactions.'\n   - An abstract method make_payment(amount) with no implementation.\n3. Create a child class CreditCardPayment that inherits from Payment and implements:\n   - make_payment(amount) that prints '<amount> paid using Credit Card'\n   - card_details() that prints the last four digits of the card.\n4. Create a child class PayPalPayment that inherits from Payment and implements:\n   - make_payment(amount) that prints '<amount> paid using PayPal'\n   - account_email() that prints the email of the PayPal account.\n5. Create objects of both child classes and call all their methods.",
                    "starterCode": "from abc import ABC, abstractmethod\n\n# Step 2: Create abstract class Payment\nclass Payment(ABC):\n    # concrete method\n    def payment_info(self):\n        # your code here\n        pass\n\n    # abstract method\n    @abstractmethod\n    def make_payment(self, amount):\n        pass\n\n# Step 3: Create CreditCardPayment class inheriting Payment\nclass CreditCardPayment(Payment):\n    # implement make_payment\n    # add card_details method\n    pass\n\n# Step 4: Create PayPalPayment class inheriting Payment\nclass PayPalPayment(Payment):\n    # implement make_payment\n    # add account_email method\n    pass\n\n# Step 5: Create objects and call methods\n# your code here",
                    "solutionCode": "from abc import ABC, abstractmethod\n\nclass Payment(ABC):\n    def payment_info(self):\n        print('This is a payment system for processing transactions.')\n\n    @abstractmethod\n    def make_payment(self, amount):\n        pass\n\nclass CreditCardPayment(Payment):\n    def make_payment(self, amount):\n        print(f'{amount} paid using Credit Card')\n\n    def card_details(self):\n        print('Card last 4 digits: 1234')\n\nclass PayPalPayment(Payment):\n    def make_payment(self, amount):\n        print(f'{amount} paid using PayPal')\n\n    def account_email(self):\n        print('paypal@example.com')\n\n# Objects\ncc_payment = CreditCardPayment()\npaypal_payment = PayPalPayment()\n\n# Method calls\ncc_payment.payment_info()\ncc_payment.card_details()\ncc_payment.make_payment(500)\npaypal_payment.payment_info()\npaypal_payment.account_email()\npaypal_payment.make_payment(750)",
                    "expectedOutput": "This is a payment system for processing transactions.\nCard last 4 digits: 1234\n500 paid using Credit Card\nThis is a payment system for processing transactions.\npaypal@example.com\n750 paid using PayPal",
                    "testCases": [
                        {
                            "mode": "execution",
                            "input": "",
                            "expectedOutput": null
                        }
                    ],
                    "structureRequirements": {
                        "classes": [
                            "Payment",
                            "CreditCardPayment",
                            "PayPalPayment"
                        ],
                        "functions": [
                            "payment_info",
                            "make_payment",
                            "card_details",
                            "account_email"
                        ],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ],
                        "modules": [
                            "abc"
                        ]
                    }
                }
            ]
        },    
        {
            "name": "Modules and Packages",
            "description": "In this topic, students will learn how Python organizes code into modules and packages, and how built-in modules provide ready-made tools for common tasks. They will explore creating their own modules, grouping them into packages, and using built-in modules like random, time, datetime, and sys to write efficient programs.",
            "mcqs": [
                {
                    "question": "What is the main purpose of a Python module?",
                    "options": [
                        "To execute code faster",
                        "To reuse code by organizing it into a separate .py file",
                        "To connect Python with databases",
                        "To automatically generate random numbers"
                    ],
                    "answer": 1,
                    "explanation": "Modules allow us to organize and reuse code by storing it in separate .py files that can be imported into other programs."
                },
                {
                    "question": "Which file makes a folder behave like a package in Python?",
                    "options": [
                        "package.py",
                        "setup.py",
                        "__init__.py",
                        "main.py"
                    ],
                    "answer": 2,
                    "explanation": "The __init__.py file marks a folder as a Python package, allowing it to contain multiple modules."
                },
                {
                    "question": "If you want to generate a random integer between 10 and 20, which function should you use?",
                    "options": [
                        "random.random(10,20)",
                        "random.randint(10,20)",
                        "random.uniform(10,20)",
                        "random.choice(10,20)"
                    ],
                    "answer": 1,
                    "explanation": "random.randint(10,20) generates a random integer between 10 and 20, both inclusive."
                },
                {
                    "question": "Which of the following functions pauses a program for a few seconds?",
                    "options": [
                        "time.sleep()",
                        "time.pause()",
                        "sys.exit()",
                        "datetime.now()"
                    ],
                    "answer": 0,
                    "explanation": "time.sleep(n) pauses the program for n seconds."
                },
                {
                    "question": "What will datetime.now() return?",
                    "options": [
                        "Only the current date",
                        "Only the current time",
                        "Both the current date and time",
                        "The number of seconds since 1970"
                    ],
                    "answer": 2,
                    "explanation": "datetime.now() returns a datetime object that contains both the current date and time."
                },
                {
                    "question": "Which module would you use if you want to exit the program early?",
                    "options": [
                        "time",
                        "sys",
                        "random",
                        "datetime"
                    ],
                    "answer": 1,
                    "explanation": "The sys module provides sys.exit(), which allows you to exit a program early."
                }
            ],
            "codeTasks": [
                {
                    "question": "Write a program using the random and time modules that simulates a lucky draw.\n\nSteps to follow:\n1. Import the random and time modules.\n2. Create a list of at least 5 participant names.\n3. Print 'Starting the lucky draw...' and pause for 3 seconds using time.sleep().\n4. Use random.choice() to select one winner from the list.\n5. Print 'The winner is: <name>'.",
                    "starterCode": "import random\nimport time\n\n# Step 2: Create a list of participants\nparticipants = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\n\n# Step 3: Print starting message and pause\n# your code here\n\n# Step 4: Select a random winner\n# your code here\n\n# Step 5: Print winner\n# your code here",
                    "solutionCode": "import random\nimport time\n\nparticipants = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\n\nprint('Starting the lucky draw...')\ntime.sleep(3)\n\nwinner = random.choice(participants)\nprint('The winner is:', winner)",
                    "expectedOutput": "Starting the lucky draw...\n(The program pauses for 3 seconds)\nThe winner is: Alice",
                    "testCases": [
                        {
                            "mode": "execution",
                            "input": "",
                            "expectedOutput": null
                        }
                    ],
                    "structureRequirements": {
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "forbidden": [
                            "eval(",
                            "exec("
                        ],
                        "modules": [
                            "random",
                            "time"
                        ]
                    }
                }
            ]
        },
        {
            "name": "Exception Handling",
            "description": "Understanding the difference between syntax errors and exceptions. Using try, except, else, and finally to handle exceptions gracefully, and learning to raise exceptions manually.",
            "mcqs": [
                {
                    "question": "What is the main difference between a SyntaxError and a ZeroDivisionError?",
                    "options": [
                        "A SyntaxError happens while the code is running; a ZeroDivisionError happens before the code runs.",
                        "A SyntaxError prevents the code from starting; a ZeroDivisionError happens after the code has started running.",
                        "They are the same type of error, just with different names.",
                        "A SyntaxError is caused by the user; a ZeroDivisionError is caused by the programmer."
                    ],
                    "answer": 1,
                    "explanation": "A SyntaxError is a mistake in the code's structure (like a missing parenthesis) that Python finds before it runs any code. A ZeroDivisionError is an exception that occurs during execution when the program tries to divide by zero.",
                    "topic": "Errors vs. Exceptions and Basic Handling"
                },
                {
                    "question": "Look at the following code:\n\ntry:\n    num = int(input('Enter a number: '))\n    result = 100 / num\n    print(f'Result is {result}')\nexcept ValueError:\n    print('Please enter a valid number!')\nexcept ZeroDivisionError:\n    print('You cannot divide by zero!')\n\nWhat will be the output if the user enters the word 'five'?",
                    "options": [
                        "'Result is 20.0'",
                        "'Please enter a valid number!'",
                        "'You cannot divide by zero!'",
                        "The program will crash with a red error message."
                    ],
                    "answer": 1,
                    "explanation": "The word 'five' cannot be converted to an integer by int(), so it raises a ValueError. The first except block is designed to catch this exact error and print a friendly message.",
                    "topic": "Errors vs. Exceptions and Basic Handling"
                },
                {
                    "question": "Which keyword is used to define a block of code that will always run, whether an exception occurred or not?",
                    "options": [
                        "try",
                        "except",
                        "else",
                        "finally"
                    ],
                    "answer": 3,
                    "explanation": "The finally block is the 'cleanup crew'. The code inside it runs no matter what happens in the try and except blocks—whether there was an error or not.",
                    "topic": "Errors vs. Exceptions and Basic Handling"
                },
                {
                    "question": "What does the 'raise' keyword do in Python?",
                    "options": [
                        "It catches exceptions automatically.",
                        "It stops the program without an error.",
                        "It manually triggers an exception.",
                        "It prevents errors from occurring."
                    ],
                    "answer": 2,
                    "explanation": "The raise keyword allows the programmer to manually trigger an exception, often used for input validation or custom error handling.",
                    "topic": "Errors vs. Exceptions and Basic Handling"
                },
                {
                    "question": "What is the purpose of the 'else' block in a try-except statement?",
                    "options": [
                        "It runs if an exception occurs.",
                        "It runs only if no exception occurs in the try block.",
                        "It catches all exceptions automatically.",
                        "It stops the program execution."
                    ],
                    "answer": 1,
                    "explanation": "The else block runs only if the code in the try block does not raise any exceptions. It's useful for code that should only run after a successful try.",
                    "topic": "Errors vs. Exceptions and Basic Handling"
                },
                {
                    "question": "Which of the following is a correct way to raise a ValueError when a user enters a negative number?",
                    "options": [
                        "raise NegativeNumberError('Negative number entered')",
                        "raise ValueError('Negative number entered')",
                        "raise Exception('Negative number entered')",
                        "raise InputError('Negative number entered')"
                    ],
                    "answer": 1,
                    "explanation": "ValueError is the built-in exception type used to indicate that a function received an argument of the correct type but an inappropriate value. Using raise ValueError(...) is correct.",
                    "topic": "Errors vs. Exceptions and Basic Handling"
                }
            ],
            "codeTasks": [
                {
                    "question": "Write a program that asks the user for their age. If the user enters a non-numeric value, handle it using a try-except block. If the user enters a negative number, use 'raise' to manually throw a ValueError. If the input is valid and non-negative, check if they are 13 or older and print 'Access granted.' if they are, otherwise print 'Access denied.'",
                    "starterCode": "# Step 1: Get input and handle non-numeric values\ntry:\n    age = int(input('Enter your age: '))\n    # Step 2: Raise ValueError for negative numbers\n    # your code here\n\n    # Step 3: Check age and print access message\n    # your code here\nexcept ValueError as ve:\n    print('Invalid input:', ve)",
                    "solutionCode": "try:\n    age = int(input('Enter your age: '))\n    if age < 0:\n        raise ValueError('Age cannot be negative.')\n    if age >= 13:\n        print('Access granted.')\n    else:\n        print('Access denied.')\nexcept ValueError as ve:\n    print('Invalid input:', ve)",
                    "expectedOutput": "Example 1 Input: '12' → Output: 'Access denied.'\nExample 2 Input: '15' → Output: 'Access granted.'\nExample 3 Input: '-5' → Output: 'Invalid input: Age cannot be negative.'\nExample 4 Input: 'hello' → Output: 'Invalid input: invalid literal for int() with base 10: 'hello''",
                    "testCases": [
                        {
                            "mode": "io",
                            "input": [
                                "12"
                            ],
                            "expected": "Access denied."
                        },
                        {
                            "mode": "io",
                            "input": [
                                "15"
                            ],
                            "expected": "Access granted."
                        },
                        {
                            "mode": "io",
                            "input": [
                                "-5"
                            ],
                            "expected": "Invalid input: Age cannot be negative."
                        },
                        {
                            "mode": "io",
                            "input": [
                                "hello"
                            ],
                            "expected": "Invalid input: invalid literal for int() with base 10: 'hello'"
                        }
                    ],
                    "structureRequirements": {
                        "functions": [],
                        "mustUseForLoop": false,
                        "mustUseWhileLoop": false,
                        "mustUseTryExcept": true,
                        "mustUseRaise": true,
                        "forbidden": []
                    }
                }
            ]
        },
        {
            "name": "Turtle Graphics",
            "description": "Introduction to the turtle module in Python. Students will learn how to create a screen, control a turtle (pen), draw shapes, and handle user inputs using try-except and raise statements.",
            "mcqs": [
                {
                    "question": "What does the turtle module in Python allow you to do?",
                    "options": [
                        "Generate random numbers",
                        "Create graphical drawings by controlling a virtual pen",
                        "Add delays in program execution",
                        "Perform mathematical calculations faster"
                    ],
                    "answer": 1,
                    "explanation": "The turtle module provides a visual way to draw shapes and designs by controlling a virtual 'turtle' on the screen."
                },
                {
                    "question": "Which command is used to keep the turtle screen open until you close it manually?",
                    "options": [
                        "turtle.open()",
                        "screen.mainloop()",
                        "turtle.exit()",
                        "screen.keepopen()"
                    ],
                    "answer": 1,
                    "explanation": "screen.mainloop() keeps the turtle graphics window open until the user closes it manually."
                },
                {
                    "question": "By default, where does the turtle start on the screen when you create a new turtle using turtle.Turtle()?",
                    "options": [
                        "Top-left corner",
                        "Bottom-right corner",
                        "Center of the screen facing right (0 degrees)",
                        "Random position on the screen"
                    ],
                    "answer": 2,
                    "explanation": "When a new turtle is created, it starts at the center of the screen facing right, which is considered 0 degrees."
                },
                {
                    "question": "What does pen.forward(100) do?",
                    "options": [
                        "Turns the pen 100 degrees",
                        "Moves the pen forward by 100 units in the direction it is facing",
                        "Moves the pen to coordinate (100,100)",
                        "Sets the pen color to 100"
                    ],
                    "answer": 1,
                    "explanation": "pen.forward(100) moves the turtle forward by 100 units in the direction it is currently facing."
                },
                {
                    "question": "How do you turn the turtle clockwise by 90 degrees?",
                    "options": [
                        "pen.left(90)",
                        "pen.right(90)",
                        "pen.turn(90)",
                        "turtle.rotate(90)"
                    ],
                    "answer": 1,
                    "explanation": "pen.right(90) turns the turtle clockwise by 90 degrees."
                },
                {
                    "question": "If you want the turtle to draw a green line, which command would you use?",
                    "options": [
                        "pen.color('green')",
                        "turtle.penColor('green')",
                        "screen.color('green')",
                        "pen.setColor('green')"
                    ],
                    "answer": 0,
                    "explanation": "pen.color('green') sets the pen color to green, so any line drawn after this will appear in green."
                },
                {
                    "question": "Which command will turn the turtle counterclockwise by 90 degrees?",
                    "options": [
                        "pen.right(90)",
                        "pen.left(90)",
                        "turtle.turnLeft(90)",
                        "screen.left(90)"
                    ],
                    "answer": 1,
                    "explanation": "pen.left(90) turns the turtle counterclockwise by 90 degrees."
                }
            ]
        }
    ]
}